"""Dead simple C++ backend
"""
from . import ast
from . import resolver
from mtots import util
import contextlib


class StringBuilder:
    def __init__(self, depth=0):
        self.parts = []
        self.depth = depth

    def __iadd__(self, line):
        self.parts.append(f'{"  " * self.depth}{line}\n')
        return self

    @contextlib.contextmanager
    def indent(self):
        self.depth += 1
        try:
            yield
        finally:
            self.depth -= 1

    def __str__(self):
        return ''.join(self.parts)


_primitive_type_map = {
    'void': 'NCX_VOID',
    'bool': 'NCX_BOOL',
    'int': 'NCX_INT',
    'double': 'NCX_DOUBLE',
    'string': 'NCX_STRING',
}

_cxx_prologue_fwd = r"""// <generated by nc transpiler>
#include <iostream>
#include <memory>
#include <string>
using NCX_VOID = int;
using NCX_BOOL = bool;
using NCX_INT = long;
using NCX_DOUBLE = double;
using NCX_STRING = std::shared_ptr<std::string>;
struct NCXX_ZUpreludeZDObject;
template <class T> NCX_STRING NCXX_ZUpreludeZDstr(T x) {
    return x->NCX_str();
}
template <> NCX_STRING NCXX_ZUpreludeZDstr(NCX_STRING s) {
    return s;
}
"""

_cxx_prologue_hdr = r"""struct NCXX_ZUpreludeZDObject {
    virtual NCX_STRING NCX_str();
};
NCX_VOID NCXX_ZUpreludeZDprintstr(NCX_STRING s);
NCX_STRING NCX_mkstr(const char *s);
"""

_cxx_prologue_src = r"""NCX_STRING NCX_mkstr(const char *s) {
    return std::make_shared<std::string>(s);
}
NCX_STRING NCXX_ZUpreludeZDObject::NCX_str() {
    return NCX_mkstr("<Object>");
}
NCX_VOID NCXX_ZUpreludeZDprintstr(NCX_STRING s) {
    std::cout << *s << std::endl;
    return 0;
}
"""

_cxx_epilogue_src = r"""int main() {
    NCXX_ZUmainZDmain();
}
"""


def render(ast_table):
    fwd = StringBuilder()
    hdr = StringBuilder()
    src = StringBuilder()

    fwd.parts.append(_cxx_prologue_fwd)
    hdr.parts.append(_cxx_prologue_hdr)
    src.parts.append(_cxx_prologue_src)

    for node in ast_table.values():
        _render_file_level_statement(node, fwd, hdr, src)

    src.parts.append(_cxx_epilogue_src)

    return ''.join(map(str, [fwd, hdr, src]))


def _cname(name):
    return 'NCXX_' + (
        name
            .replace('Z', 'ZZ')
            .replace('_', 'ZU')
            .replace('.', 'ZD')
            .replace('$', 'ZR')
            .replace('#', 'ZH')
    )


@util.multimethod(1)
def _render_file_level_statement(on):

    @on(ast.Class)
    def r(node, fwd, hdr, src):
        c_class_name = _cname(node.name)

        if node.native:
            fwd += f'// (native class {node.name}) {c_class_name}'
            for field in node.fields:
                fwd += f'//   {_declare(field.type, _cname(field.name))}'
            return

        fwd += f'struct {c_class_name};'
        hdr += f'struct {c_class_name} ' '{'
        with hdr.indent():
            for field in node.fields:
                hdr += f'{_declare(field.type, _cname(field.name))};'
        hdr += '};'

    @on(ast.Function)
    def r(node, fwd, hdr, src):

        c_function_name = _cname(node.name)
        proto = _declare(node)

        if node.native:
            fwd += f'// (native function {node.name}) {proto}'
            return

        if node.generic:
            out = hdr
        else:
            hdr += f'{proto};'
            out = src

        if node.body is not None:
            out += f'{proto} ' '{'
            with out.indent():
                out += f'return {_render_expression(node.body, 1)};'
            out += '}'


@util.multimethod(1)
def _declare(on):

    @on(ast.Function)
    def r(node):
        if node.generic:
            tparams = ','.join(
                f'class {_cname(tparam.name)}'
                for tparam in node.type_parameters)
            generic = f'template <{tparams}> '
        else:
            generic = ''
        c_function_name = _cname(node.name)
        parameters = ', '.join(_declare(param) for param in node.parameters)
        dtor = f'{c_function_name}({parameters})'
        return f'{generic}{_declare(node.return_type, dtor)}'

    @on(ast.Parameter)
    def r(node):
        return f'{_declare(node.type, _cname(node.name))}'

    @on(ast.TypeParameter)
    def r(type_, dtor):
        return f'{_cname(type_.name)} {dtor}'

    @on(ast.PrimitiveType)
    def r(type_, dtor):
        return f'{_primitive_type_map[type_.name]} {dtor}'


@util.multimethod(1)
def _render_expression(on):
    @on(ast.Block)
    def r(node, depth):
        parts = []
        parts.append('([&](){\n')
        exprs = node.expressions
        inner_indent = '  ' * (depth + 1)
        if exprs:
            for expr in exprs[:-1]:
                parts.append(
                    f'{inner_indent}'
                    f'{_render_expression(expr, depth + 1)};\n')
            parts.append(
                f'{inner_indent}'
                f'return {_render_expression(exprs[-1], depth + 1)};\n'
            )
        else:
            parts.append(f'{inner_indent}return 0;\n')
        parts.append('  ' * depth + '})()')
        return ''.join(parts)

    @on(ast.FunctionCall)
    def r(node, depth):
        c_function_name = _cname(node.function.name)
        arguments = ', '.join(
            _render_expression(e, depth) for e in node.arguments)
        return f'{c_function_name}({arguments})'

    @on(ast.Int)
    def r(node, depth):
        return f'{node.value}L'

    @on(ast.String)
    def r(node, depth):
        contents = (
            node.value
                .replace('\n', '\\n')
                .replace('\\', '\\\\')
        )
        return f'NCX_mkstr("{contents}")'

    @on(ast.LocalVariable)
    def r(node, depth):
        return _cname(node.declaration.name)


def main():
    data = resolver.load(r"""
    void main() = {
        print("Hello world!")
    }
    """)
    print(render(data))


if __name__ == '__main__':
    main()
